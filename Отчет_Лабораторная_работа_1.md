# ОТЧЕТ ПО ЛАБОРАТОРНОЙ РАБОТЕ №1

**Дисциплина:** Функциональное программирование  
**Тема:** Простые алгоритмы и встроенные структуры данных  
**Студент:** Багманов Владимир Алексеевич
**Группа:** P3330

---

## ОПИСАНИЕ ПРОБЛЕМЫ

В рамках лабораторной работы решались две задачи из проекта Эйлер:

### Задача 1: Наибольший простой делитель
Найти наибольший простой делитель числа 600851475143.  
Простые делители числа 13195: 5, 7, 13 и 29.

### Задача 2: Сумма диагоналей спирали
Найти сумму чисел на диагоналях спирали размером 1001×1001.  
Для спирали 5×5:
```
21 22 23 24 25
20  7  8  9 10
19  6  1  2 11
18  5  4  3 12
17 16 15 14 13
```
Сумма диагоналей = 101.

Каждая задача реализована шестью различными способами:
1. Хвостовая рекурсия
2. Обычная рекурсия  
3. Модульная реализация (генерация → фильтрация → свёртка)
4. Отображение (map)
5. Циклы
6. Бесконечные последовательности

---

## КЛЮЧЕВЫЕ ЭЛЕМЕНТЫ РЕАЛИЗАЦИИ

### 1. Хвостовая рекурсия
```fsharp
// Задача 1: Поиск наибольшего простого делителя
let solveTailRecursion n =
    let rec loop acc divisor num =
        if num = 1L then acc
        elif num % divisor = 0L then loop divisor divisor (num / divisor)
        else loop acc (divisor + 1L) num
    loop 1L 2L n
```

**Особенности:** Использование аккумулятора для избежания переполнения стека.

### 2. Обычная рекурсия
```fsharp
// Задача 1: Рекурсивный поиск с максимумом
let solveRecursion n =
    let rec largestPrimeFactorFrom m i =
        if i * i > m then m
        elif m % i = 0L then max (largestPrimeFactorFrom (m / i) i) i
        else largestPrimeFactorFrom m (i + 1L)
    largestPrimeFactorFrom n 2L
```

**Особенности:** Прямая рекурсия с вычислением максимума на каждом уровне.

### 3. Модульная реализация
```fsharp
// Задача 1: Разделение на этапы
let generateCandidates n = seq { 2L .. int64 (sqrt (float n)) }
let filterPrimeDivisors n = 
    generateCandidates n |> Seq.filter (fun d -> n % d = 0L && isPrime d)
let solveModules n = 
    filterPrimeDivisors n |> Seq.fold (fun acc d -> if d > acc then d else acc) 1L
```

**Особенности:** Явное разделение генерации, фильтрации и свёртки.

### 4. Отображение (Map)
```fsharp
// Задача 1: Использование Seq.unfold и map
let factors n =
    Seq.unfold (fun (n, d) ->
        if n = 1L then None
        elif n % d = 0L then Some(d, (n / d, d))
        elif d * d > n then Some(n, (1L, n))
        else Some(0L, (n, d + 1L))) (n, 2L)
    |> Seq.filter ((<>) 0L)
    |> Seq.map id

let solveMap n = factors n |> Seq.max
```

**Особенности:** Генерация последовательности через unfold с последующим отображением.

### 5. Циклы
```fsharp
// Задача 1: Императивный стиль с мутабельными переменными
let solveCycle (n: int64) =
    let mutable num = n
    let mutable factor = 2L
    let mutable last = 1L
    
    while factor * factor <= num do
        if num % factor = 0L then
            last <- factor
            num <- num / factor
        else
            factor <- factor + 1L
    
    if num > 1L then num else last
```

**оправдание:** Я не нашел иммутабельного варианта, добавил чтобы с ним поработать
**Особенности:** Использование мутабельных переменных и циклов while.

### 6. Бесконечные последовательности
```fsharp
// Задача 1: Работа с бесконечной последовательностью кандидатов
let solveInf n =
    let rec loop num (candidates: seq<int64>) =
        let d = candidates |> Seq.head
        if d * d > num then num
        elif num % d = 0L then loop (num / d) candidates
        else loop num (candidates |> Seq.tail)
    
    loop n (Seq.initInfinite (fun i -> int64 (i + 2)))
```

**Особенности:** Использование `Seq.initInfinite` для создания бесконечной последовательности.

### 7. Сравнение с C++
```cpp
// Традиционная императивная реализация
long long largestPrimeFactor(long long n) {
    long long maxPrime = 1;
    while (n % 2 == 0) {
        maxPrime = 2;
        n /= 2;
    }
    for (long long i = 3; i <= sqrt(n); i += 2) {
        while (n % i == 0) {
            maxPrime = i;
            n /= i;
        }
    }
    if (n > 2) maxPrime = n;
    return maxPrime;
}
```

**Особенности:** Прямолинейный алгоритм с оптимизацией для четных чисел.

---

## ВЫВОДЫ

### Функциональные приёмы программирования

**Хвостовая рекурсия** показала себя как эффективный способ избежания переполнения стека при сохранении функционального стиля. Использование аккумулятора делает код более предсказуемым по памяти.

**Обычная рекурсия** обеспечивает наиболее естественное выражение алгоритма, но может привести к переполнению стека на больших данных. Подходит для задач с ограниченной глубиной рекурсии.

**Модульная реализация** демонстрирует силу композиции функций в F#. Разделение на генерацию, фильтрацию и свёртку делает код более читаемым и тестируемым, хотя может быть менее эффективным по производительности.

**Отображение (map)** с использованием `Seq.unfold` позволяет элегантно генерировать последовательности. Этот подход особенно мощен для создания сложных трансформаций данных.

**Циклы** в F# сохраняют привычный императивный стиль, но требуют явного использования мутабельных переменных, что нарушает принципы функционального программирования.

**Бесконечные последовательности** демонстрируют ленивые вычисления F#. Позволяют работать с потенциально бесконечными данными, вычисляя только необходимые элементы.

### Сравнение с традиционным программированием

C++ реализация показывает более прямолинейный подход с явным управлением памятью и циклами. F# предоставляет более высокий уровень абстракции через функции высшего порядка и композицию.

Функциональный подход в F# способствует написанию более декларативного кода, где акцент делается на "что делать", а не на "как делать". Это повышает читаемость и снижает количество ошибок, связанных с управлением состоянием.

### Производительность и читаемость

Императивные решения (циклы, C++) показывают лучшую производительность, но функциональные подходы обеспечивают лучшую композируемость и тестируемость кода. Модульная реализация особенно ценна для сложных алгоритмов, где важна ясность логики.

Использование различных парадигм в рамках одного языка (F#) демонстрирует гибкость современных функциональных языков и возможность выбора оптимального подхода для конкретной задачи.